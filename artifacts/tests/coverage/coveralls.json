{"service_name":"travis-ci","service_job_id":"8833880","git":{"branch":"(detached from 127f05c)","head":{"id":"127f05c9a5e05b0bc68da975e097eb9e5d1c7426","author_name":"James Harris","author_email":"james.harris@icecave.com.au","committer_name":"James Harris","committer_email":"james.harris@icecave.com.au","message":"Merge branch 'release\/0.2.0' into develop"},"remotes":[{"name":"origin","url":"git:\/\/github.com\/IcecaveStudios\/duct.git"}]},"run_at":"2013-07-08 02:24:24 +0000","source_files":[{"name":"Icecave\/Duct\/AbstractParser.php","source":"<?php\nnamespace Icecave\\Duct;\n\nuse Icecave\\Duct\\Detail\\Lexer;\nuse Icecave\\Duct\\Detail\\TokenStreamParser;\nuse Icecave\\Duct\\TypeCheck\\TypeCheck;\n\n\/**\n * Streaming JSON parser.\n *\n * Converts incoming streams of JSON data into PHP values.\n *\/\nabstract class AbstractParser\n{\n    \/**\n     * @param Lexer|null             $lexer  The lexer to use for tokenization, or NULL to use the default UTF-8 lexer.\n     * @param TokenStreamParser|null $parser The token-stream parser to use for converting tokens into PHP values, or null to use the default.\n     *\/\n    public function __construct(Lexer $lexer = null, TokenStreamParser $parser = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        if (null === $lexer) {\n            $lexer = new Lexer;\n        }\n\n        if (null === $parser) {\n            $parser = new TokenStreamParser;\n        }\n\n        $this->lexer = $lexer;\n        $this->parser = $parser;\n    }\n\n    \/**\n     * Parse one or more complete JSON values.\n     *\n     * @param string $buffer The JSON data.\n     *\n     * @return Vector<mixed>             The sequence of parsed JSON values.\n     * @throws Exception\\ParserException Indicates that the JSON stream terminated midway through a JSON value.\n     *\/\n    public function parse($buffer)\n    {\n        $this->typeCheck->parse(func_get_args());\n\n        $this->reset();\n        $this->feed($buffer);\n        $this->finalize();\n    }\n\n    \/**\n     * Reset the parser, discarding any previously parsed input and values.\n     *\/\n    public function reset()\n    {\n        $this->typeCheck->reset(func_get_args());\n\n        $this->lexer->reset();\n        $this->parser->reset();\n    }\n\n    \/**\n     * Feed (potentially incomplete) JSON data to the parser.\n     *\n     * @param string $buffer The JSON data.\n     *\/\n    public function feed($buffer)\n    {\n        $this->typeCheck->feed(func_get_args());\n\n        $this->lexer->feed($buffer);\n        $this->parser->feed($this->lexer->tokens());\n    }\n\n    \/**\n     * Finalize parsing.\n     *\n     * @throws Exception\\ParserException Indicates that the JSON stream terminated midway through a JSON value.\n     *\/\n    public function finalize()\n    {\n        $this->typeCheck->finalize(func_get_args());\n\n        $this->lexer->finalize();\n        $this->parser->feed($this->lexer->tokens());\n        $this->parser->finalize();\n    }\n\n    private $typeCheck;\n    protected $lexer;\n    protected $parser;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,7,null,7,7,7,null,7,7,7,null,7,7,7,null,null,null,null,null,null,null,null,null,null,null,7,null,7,7,7,7,null,null,null,null,null,null,7,null,7,7,7,null,null,null,null,null,null,null,null,7,null,7,7,7,null,null,null,null,null,null,null,null,7,null,7,7,7,7,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/Exception\/LexerException.php","source":"<?php\nnamespace Icecave\\Duct\\Detail\\Exception;\n\nuse Icecave\\Duct\\Exception\\SyntaxExceptionInterface;\nuse RuntimeException;\n\nclass LexerException extends RuntimeException implements SyntaxExceptionInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/Exception\/ParserException.php","source":"<?php\nnamespace Icecave\\Duct\\Detail\\Exception;\n\nuse Icecave\\Duct\\Exception\\SyntaxExceptionInterface;\nuse RuntimeException;\n\nclass ParserException extends RuntimeException implements SyntaxExceptionInterface\n{\n}","coverage":[null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/Lexer.php","source":"<?php\nnamespace Icecave\\Duct\\Detail;\n\nuse Icecave\\Collections\\Vector;\nuse Icecave\\Duct\\TypeCheck\\TypeCheck;\n\n\/**\n * Streaming JSON lexer.\n *\n * Converts incoming streams of JSON data into tokens.\n *\/\nclass Lexer\n{\n    \/**\n     * @param string $encoding The encoding of the incoming JSON data stream.\n     *\/\n    public function __construct($encoding = 'UTF-8')\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->encoding = $encoding;\n\n        $this->reset();\n    }\n\n    \/**\n     * Reset the lexer, discarding any untokened input.\n     *\/\n    public function reset()\n    {\n        $this->typeCheck->reset(func_get_args());\n\n        $this->state = LexerState::BEGIN();\n        $this->inputBuffer = '';\n        $this->tokenBuffer = '';\n        $this->unicodeBuffer = '';\n        $this->tokens = new Vector;\n    }\n\n    \/**\n     * Tokenize JSON data.\n     *\n     * @param string $buffer The JSON data.\n     *\n     * @return Vector<Token>            The sequence of tokens representing the JSON data.\n     * @throws Exception\\LexerException Indicates that the input terminated midway through a token.\n     *\/\n    public function lex($buffer)\n    {\n        $this->typeCheck->lex(func_get_args());\n\n        $this->reset();\n        $this->feed($buffer);\n        $this->finalize();\n\n        return $this->tokens();\n    }\n\n    \/**\n     * Feed JSON data to the lexer.\n     *\n     * @param string $buffer The JSON data.\n     *\/\n    public function feed($buffer)\n    {\n        $this->typeCheck->feed(func_get_args());\n\n        $length = strlen($buffer);\n\n        for ($index = 0; $index < $length; ++$index) {\n            $this->inputBuffer .= $buffer[$index];\n            $this->consume();\n        }\n    }\n\n    \/**\n     * Complete tokenization.\n     *\n     * @throws Exception\\LexerException Indicates that the input terminated midway through a token.\n     *\/\n    public function finalize()\n    {\n        $this->typeCheck->finalize(func_get_args());\n\n        switch ($this->state) {\n            case LexerState::NUMBER_VALUE_NEGATIVE():\n            case LexerState::NUMBER_VALUE_EXPONENT_START():\n            case LexerState::STRING_VALUE():\n            case LexerState::STRING_VALUE_ESCAPED():\n            case LexerState::STRING_VALUE_UNICODE():\n            case LexerState::TRUE_VALUE():\n            case LexerState::FALSE_VALUE():\n            case LexerState::NULL_VALUE():\n                throw new Exception\\LexerException('Character stream ended while scanning literal value.');\n\n            case LexerState::NUMBER_VALUE():\n            case LexerState::NUMBER_VALUE_LEADING_ZERO():\n                $this->emitLiteral(intval($this->tokenBuffer));\n                break;\n\n            case LexerState::NUMBER_VALUE_DECIMAL():\n            case LexerState::NUMBER_VALUE_EXPONENT():\n                $this->emitLiteral(floatval($this->tokenBuffer));\n                break;\n        }\n    }\n\n    \/**\n     * Fetch the tokens produced by the lexer so far and remove them from the internal token sequence.\n     *\n     * @return Vector<Token> The sequence of tokens representing the JSON value.\n     *\/\n    public function tokens()\n    {\n        $this->typeCheck->tokens(func_get_args());\n\n        $tokens = clone $this->tokens;\n        $this->tokens->clear();\n\n        return $tokens;\n    }\n\n    private function consume()\n    {\n        if (!mb_check_encoding($this->inputBuffer, $this->encoding)) {\n            return;\n        }\n\n        $char = $this->inputBuffer;\n        $this->inputBuffer = '';\n\n        switch ($this->state) {\n            case LexerState::STRING_VALUE():\n                return $this->doStringValue($char);\n            case LexerState::STRING_VALUE_ESCAPED():\n                return $this->doStringValueEscaped($char);\n            case LexerState::STRING_VALUE_UNICODE():\n                return $this->doStringValueUnicode($char);\n            case LexerState::NUMBER_VALUE():\n                return $this->doNumberValue($char);\n            case LexerState::NUMBER_VALUE_NEGATIVE():\n                return $this->doNumberValueNegative($char);\n            case LexerState::NUMBER_VALUE_LEADING_ZERO():\n                return $this->doNumberValueLeadingZero($char);\n            case LexerState::NUMBER_VALUE_DECIMAL():\n                return $this->doNumberValueDecimal($char);\n            case LexerState::NUMBER_VALUE_EXPONENT_START():\n                return $this->doNumberValueExponentStart($char);\n            case LexerState::NUMBER_VALUE_EXPONENT():\n                return $this->doNumberValueExponent($char);\n            case LexerState::TRUE_VALUE():\n                return $this->doTrueValue($char);\n            case LexerState::FALSE_VALUE():\n                return $this->doFalseValue($char);\n            case LexerState::NULL_VALUE():\n                return $this->doNullValue($char);\n        }\n\n        return $this->doBegin($char);\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doBegin($char)\n    {\n        if ('\"' === $char) {\n            $this->state = LexerState::STRING_VALUE();\n        } elseif ('0' === $char) {\n            $this->tokenBuffer = $char;\n            $this->state = LexerState::NUMBER_VALUE_LEADING_ZERO();\n        } elseif ('-' === $char) {\n            $this->tokenBuffer = $char;\n            $this->state = LexerState::NUMBER_VALUE_NEGATIVE();\n        } elseif (ctype_digit($char)) {\n            $this->tokenBuffer = $char;\n            $this->state = LexerState::NUMBER_VALUE();\n        } elseif ('t' === $char) {\n            $this->tokenBuffer = $char;\n            $this->state = LexerState::TRUE_VALUE();\n        } elseif ('f' === $char) {\n            $this->tokenBuffer = $char;\n            $this->state = LexerState::FALSE_VALUE();\n        } elseif ('n' === $char) {\n            $this->tokenBuffer = $char;\n            $this->state = LexerState::NULL_VALUE();\n        } elseif (false !== strpos('{}[]:,', $char)) {\n            $this->emitSpecial($char);\n        } elseif (!$this->isWhitespace($char)) {\n            throw new Exception\\LexerException('Unexpected character: \"' . $char . '\".');\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doStringValue($char)\n    {\n        if ('\\\\' === $char) {\n            $this->state = LexerState::STRING_VALUE_ESCAPED();\n        } elseif (null !== $this->unicodeHighSurrogate) {\n            throw new Exception\\LexerException('Missing low surrogate for unicode surrogate pair.');\n        } elseif ('\"' === $char) {\n            $this->emitLiteral($this->tokenBuffer);\n        } else {\n            $this->tokenBuffer .= $char;\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doStringValueEscaped($char)\n    {\n        if ('u' === $char) {\n            $this->unicodeBuffer = '';\n            $this->state = LexerState::STRING_VALUE_UNICODE();\n        } elseif (null !== $this->unicodeHighSurrogate) {\n            throw new Exception\\LexerException('Missing low surrogate for unicode surrogate pair.');\n        } elseif (array_key_exists($char, self::$escapeSequences)) {\n            $this->tokenBuffer .= self::$escapeSequences[$char];\n            $this->state = LexerState::STRING_VALUE();\n        } else {\n            throw new Exception\\LexerException('Invalid escape sequence.');\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doStringValueUnicode($char)\n    {\n        if (!ctype_xdigit($char)) {\n            throw new Exception\\LexerException('Invalid escape sequence.');\n        }\n\n        $this->unicodeBuffer .= $char;\n\n        if (4 === strlen($this->unicodeBuffer)) {\n            $codepoint = hexdec($this->unicodeBuffer);\n\n            \/\/ Store high surrogate for combination later ...\n            if ($this->isUnicodeHighSurrogate($codepoint)) {\n                if (null !== $this->unicodeHighSurrogate) {\n                    throw new Exception\\LexerException('Multiple high surrogates for unicode surrogate pair.');\n                }\n                $this->unicodeHighSurrogate = $codepoint;\n\n            \/\/ Combine high + low surrogate ...\n            } elseif ($this->isUnicodeLowSurrogate($codepoint)) {\n                if (null === $this->unicodeHighSurrogate) {\n                    throw new Exception\\LexerException('Missing high surrogate for unicode surrogate pair.');\n                }\n                $codepoint = $this->combineUnicodeSurrogateCodepoints($this->unicodeHighSurrogate, $codepoint);\n                $this->tokenBuffer .= $this->convertUnicodeCodepoint($codepoint);\n                $this->unicodeHighSurrogate = null;\n\n            \/\/ Regular (non-surrogate) code-point ...\n            } else {\n                $this->tokenBuffer .= $this->convertUnicodeCodepoint($codepoint);\n            }\n\n            $this->state = LexerState::STRING_VALUE();\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doNumberValue($char)\n    {\n        if (ctype_digit($char)) {\n            $this->tokenBuffer .= $char;\n        } elseif ('.' === $char) {\n            $this->tokenBuffer .= '.';\n            $this->state = LexerState::NUMBER_VALUE_DECIMAL();\n        } elseif ('e' === $char || 'E' === $char) {\n            $this->tokenBuffer .= 'e';\n            $this->state = LexerState::NUMBER_VALUE_EXPONENT_START();\n        } else {\n            $this->emitLiteral(intval($this->tokenBuffer));\n            $this->doBegin($char);\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doNumberValueNegative($char)\n    {\n        if ('0' === $char) {\n            $this->tokenBuffer .= $char;\n            $this->state = LexerState::NUMBER_VALUE_LEADING_ZERO();\n        } elseif (ctype_digit($char)) {\n            $this->tokenBuffer .= $char;\n            $this->state = LexerState::NUMBER_VALUE();\n        } else {\n            throw new Exception\\LexerException('Expected digit after negative sign.');\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doNumberValueLeadingZero($char)\n    {\n        if ('.' === $char) {\n            $this->tokenBuffer .= '.';\n            $this->state = LexerState::NUMBER_VALUE_DECIMAL();\n        } elseif ('e' === $char || 'E' === $char) {\n            $this->tokenBuffer .= 'e';\n            $this->state = LexerState::NUMBER_VALUE_EXPONENT_START();\n        } else {\n            $this->emitLiteral(intval($this->tokenBuffer));\n            $this->doBegin($char);\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doNumberValueDecimal($char)\n    {\n        if (ctype_digit($char)) {\n            $this->tokenBuffer .= $char;\n        } elseif ('e' === $char || 'E' === $char) {\n            $this->tokenBuffer .= 'e';\n            $this->state = LexerState::NUMBER_VALUE_EXPONENT_START();\n        } elseif ('.' === substr($this->tokenBuffer, -1)) {\n            throw new Exception\\LexerException('Expected digit after decimal point.');\n        } else {\n            $this->emitLiteral(floatval($this->tokenBuffer));\n            $this->doBegin($char);\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doNumberValueExponentStart($char)\n    {\n        if ('+' === $char || '-' === $char) {\n            $this->tokenBuffer .= $char;\n            $this->state = LexerState::NUMBER_VALUE_EXPONENT();\n        } elseif (ctype_digit($char)) {\n            $this->tokenBuffer .= $char;\n            $this->state = LexerState::NUMBER_VALUE_EXPONENT();\n        } else {\n            throw new Exception\\LexerException('Expected digit or +\/- as exponent.');\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doNumberValueExponent($char)\n    {\n        if (ctype_digit($char)) {\n            $this->tokenBuffer .= $char;\n        } else {\n            $this->emitLiteral(floatval($this->tokenBuffer));\n            $this->doBegin($char);\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doTrueValue($char)\n    {\n        $this->tokenBuffer .= $char;\n\n        if ($this->expectString('true')) {\n            $this->emitLiteral(true);\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doFalseValue($char)\n    {\n        $this->tokenBuffer .= $char;\n\n        if ($this->expectString('false')) {\n            $this->emitLiteral(false);\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function doNullValue($char)\n    {\n        $this->tokenBuffer .= $char;\n\n        if ($this->expectString('null')) {\n            $this->emitLiteral(null);\n        }\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function isWhitespace($char)\n    {\n        return preg_match('\/\\s\/u', $char);\n    }\n\n    \/**\n     * @param string $char\n     *\/\n    private function emitSpecial($char)\n    {\n        $this->tokens->pushBack(Token::createSpecial($char));\n        $this->tokenBuffer = '';\n        $this->state = LexerState::BEGIN();\n    }\n\n    \/**\n     * @param string $value\n     *\/\n    private function emitLiteral($value)\n    {\n        $this->tokens->pushBack(Token::createLiteral($value));\n        $this->tokenBuffer = '';\n        $this->state = LexerState::BEGIN();\n    }\n\n    \/**\n     * @param string $string\n     *\/\n    private function expectString($string)\n    {\n        if ($this->tokenBuffer === $string) {\n            return true;\n        } elseif (substr($string, 0, strlen($this->tokenBuffer)) === $this->tokenBuffer) {\n            return false;\n        }\n\n        throw new Exception\\LexerException('Expected \"' . $string . '\", got \"' . $this->tokenBuffer . '\".');\n    }\n\n    \/**\n     * @param integer $codepoint\n     *\/\n    private function isUnicodeHighSurrogate($codepoint)\n    {\n        return $codepoint >= 0xd800 && $codepoint < 0xdbff;\n    }\n\n    \/**\n     * @param integer $codepoint\n     *\/\n    private function isUnicodeLowSurrogate($codepoint)\n    {\n        return $codepoint >= 0xdc00 && $codepoint < 0xdfff;\n    }\n\n    \/**\n     * @param integer $highSurrogate\n     * @param integer $lowSurrogate\n     *\/\n    private function combineUnicodeSurrogateCodepoints($highSurrogate, $lowSurrogate)\n    {\n        return 0x10000 + ($highSurrogate - 0xd800) * 0x400 + ($lowSurrogate - 0xdc00);\n    }\n\n    \/**\n     * @param integer $codepoint\n     *\/\n    private function convertUnicodeCodepoint($codepoint)\n    {\n        return mb_convert_encoding(\n            sprintf('&#%04d;', $codepoint),\n            $this->encoding,\n            'HTML-ENTITIES'\n        );\n    }\n\n    private static $escapeSequences = array(\n        'b'  => \"\\x08\",\n        'f'  => \"\\f\",\n        'n'  => \"\\n\",\n        'r'  => \"\\r\",\n        't'  => \"\\t\",\n        '\"'  => '\"',\n        '\/'  => '\/',\n        '\\\\' => '\\\\',\n    );\n\n    private $typeCheck;\n    private $encoding;\n    private $state;\n    private $inputBuffer;\n    private $tokenBuffer;\n    private $unicodeBuffer;\n    private $unicodeHighSurrogate;\n    private $tokens;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,79,null,79,null,79,79,null,null,null,null,null,null,79,null,79,79,79,79,79,79,null,null,null,null,null,null,null,null,null,null,null,50,null,50,50,50,null,50,null,null,null,null,null,null,null,null,null,79,null,79,null,79,79,79,78,65,null,null,null,null,null,null,null,null,58,null,58,58,58,58,58,58,58,58,58,8,null,50,50,6,6,null,44,44,22,22,50,50,null,null,null,null,null,null,null,null,57,null,57,57,null,57,null,null,null,null,79,1,null,null,79,79,null,79,79,24,79,18,79,9,79,26,79,7,79,7,79,10,79,18,79,13,79,3,79,3,79,3,79,null,79,null,null,null,null,null,null,null,79,24,79,7,7,55,8,8,49,24,24,41,3,3,22,3,3,19,3,3,16,10,13,1,null,78,null,null,null,null,null,null,24,19,24,2,17,14,14,6,null,24,null,null,null,null,null,null,18,9,9,18,1,9,8,8,8,1,null,17,null,null,null,null,null,null,9,1,null,null,8,null,8,7,null,null,7,5,1,null,5,null,null,7,2,1,null,1,1,1,null,null,1,1,null,null,6,6,8,null,null,null,null,null,null,26,4,26,6,6,24,15,15,15,3,3,null,26,null,null,null,null,null,null,7,2,2,7,4,4,4,1,null,6,null,null,null,null,null,null,7,4,4,7,2,2,2,1,1,null,7,null,null,null,null,null,null,10,9,10,2,2,4,1,null,1,1,null,9,null,null,null,null,null,null,18,8,8,18,9,9,9,1,null,17,null,null,null,null,null,null,13,12,12,1,1,null,13,null,null,null,null,null,null,3,null,3,1,1,3,null,null,null,null,null,null,3,null,3,1,1,3,null,null,null,null,null,null,3,null,3,1,1,3,null,null,null,null,null,null,7,null,null,null,null,null,null,null,10,10,10,10,null,null,null,null,null,null,51,51,51,51,null,null,null,null,null,null,9,3,9,9,null,null,3,null,null,null,null,null,null,null,7,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,2,2,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/LexerState.php","source":"<?php\nnamespace Icecave\\Duct\\Detail;\n\nuse Eloquent\\Enumeration\\Enumeration;\n\nclass LexerState extends Enumeration\n{\n    const BEGIN = 0;\n\n    const STRING_VALUE         = 10;\n    const STRING_VALUE_ESCAPED = 11;\n    const STRING_VALUE_UNICODE = 12;\n\n    const NUMBER_VALUE                = 20;\n    const NUMBER_VALUE_NEGATIVE       = 21;\n    const NUMBER_VALUE_LEADING_ZERO   = 22;\n    const NUMBER_VALUE_DECIMAL        = 24;\n    const NUMBER_VALUE_EXPONENT_START = 25;\n    const NUMBER_VALUE_EXPONENT       = 26;\n\n    const TRUE_VALUE = 30;\n\n    const FALSE_VALUE = 40;\n\n    const NULL_VALUE = 50;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/ParserState.php","source":"<?php\nnamespace Icecave\\Duct\\Detail;\n\nuse Eloquent\\Enumeration\\Enumeration;\n\nclass ParserState extends Enumeration\n{\n    const BEGIN = 0;\n\n    const ARRAY_START           = 10;\n    const ARRAY_VALUE_SEPARATOR = 11;\n\n    const OBJECT_START           = 20;\n    const OBJECT_KEY             = 21;\n    const OBJECT_KEY_SEPARATOR   = 22;\n    const OBJECT_VALUE_SEPARATOR = 23;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/Token.php","source":"<?php\nnamespace Icecave\\Duct\\Detail;\n\nuse Icecave\\Duct\\TypeCheck\\TypeCheck;\n\n\/**\n * A JSON token produced by the lexer.\n *\/\nclass Token\n{\n    \/**\n     * @param TokenType $type  The type of this token.\n     * @param mixed     $value The token's value.\n     *\/\n    public function __construct(TokenType $type, $value)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->type = $type;\n        $this->value = $value;\n    }\n\n    \/**\n     * Create a 'special' token.\n     *\n     * Special tokens are the meaningful JSON characters outside of primitive values, such as braces, brackets, etc.\n     *\n     * @param string $value The character of the special token.\n     *\n     * @return Token The resulting token.\n     *\/\n    public static function createSpecial($value)\n    {\n        TypeCheck::get(__CLASS__)->createSpecial(func_get_args());\n\n        return new Token(TokenType::instanceByValue($value), $value);\n    }\n\n    \/**\n     * Create a token that represents a literal value.\n     *\n     * Literal values are the primitive values that may be expressed directly in the JSON grammar, such as strings, boolean, numbers, etc.\n     *\n     * @param mixed $value The literal value.\n     *\n     * @return Token The resulting token.\n     *\/\n    public static function createLiteral($value)\n    {\n        TypeCheck::get(__CLASS__)->createLiteral(func_get_args());\n\n        if (is_integer($value) || is_float($value)) {\n            return new Token(TokenType::NUMBER_LITERAL(), $value);\n        } elseif (is_bool($value)) {\n            return new Token(TokenType::BOOLEAN_LITERAL(), $value);\n        } elseif (is_null($value)) {\n            return new Token(TokenType::NULL_LITERAL(), null);\n        } else {\n            return new Token(TokenType::STRING_LITERAL(), strval($value));\n        }\n    }\n\n    \/**\n     * Fetch the type of the token.\n     *\n     * @return TokenType The type of the token.\n     *\/\n    public function type()\n    {\n        $this->typeCheck->type(func_get_args());\n\n        return $this->type;\n    }\n\n    \/**\n     * Fetch the value of the token.\n     *\n     * @return mixed The value of the token.\n     *\/\n    public function value()\n    {\n        $this->typeCheck->value(func_get_args());\n\n        return $this->value;\n    }\n\n    private $typeCheck;\n    private $type;\n    private $value;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,57,null,57,57,57,null,null,null,null,null,null,null,null,null,null,null,null,10,null,10,null,null,null,null,null,null,null,null,null,null,null,null,null,51,null,51,34,17,2,15,1,null,14,null,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,57,null,57,null,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/TokenStreamParser.php","source":"<?php\nnamespace Icecave\\Duct\\Detail;\n\nuse Evenement\\EventEmitter;\nuse Icecave\\Collections\\Stack;\nuse Icecave\\Duct\\TypeCheck\\TypeCheck;\nuse stdClass;\n\n\/**\n * Streaming token parser.\n *\n * Converts incoming streams of JSON tokens into PHP values.\n *\/\nclass TokenStreamParser extends EventEmitter\n{\n    public function __construct()\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        $this->reset();\n    }\n\n    \/**\n     * Reset the parser, discarding any previously parsed input and values.\n     *\/\n    public function reset()\n    {\n        $this->typeCheck->reset(func_get_args());\n\n        $this->stack = new Stack;\n    }\n\n    \/**\n     * Feed tokens to the parser.\n     *\n     * @param mixed<Token> $tokens The sequence of tokens.\n     *\/\n    public function feed($tokens)\n    {\n        $this->typeCheck->feed(func_get_args());\n\n        foreach ($tokens as $token) {\n            $this->feedToken($token);\n        }\n    }\n\n    \/**\n     * Finalize parsing.\n     *\n     * @throws Exception\\ParserException Indicates that the token stream terminated midway through a JSON value.\n     *\/\n    public function finalize()\n    {\n        $this->typeCheck->finalize(func_get_args());\n\n        if (!$this->stack->isEmpty()) {\n            throw new Exception\\ParserException('Token stream ended while parsing ' . gettype($this->stack->next()->value) . '.');\n        }\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function feedToken(Token $token)\n    {\n        if (!$this->stack->isEmpty()) {\n            switch ($this->stack->next()->state) {\n                case ParserState::ARRAY_START():\n                    return $this->doArrayStart($token);\n                case ParserState::ARRAY_VALUE_SEPARATOR():\n                    return $this->doArrayValueSeparator($token);\n                case ParserState::OBJECT_START():\n                    return $this->doObjectStart($token);\n                case ParserState::OBJECT_KEY():\n                    return $this->doObjectKey($token);\n                case ParserState::OBJECT_KEY_SEPARATOR():\n                    return $this->doObjectKeySeparator($token);\n                case ParserState::OBJECT_VALUE_SEPARATOR():\n                    return $this->doObjectValueSeparator($token);\n            }\n        }\n\n        return $this->doValue($token);\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function doValue(Token $token)\n    {\n        switch ($token->type()) {\n            case TokenType::BRACE_OPEN():\n                $this->push(new stdClass, ParserState::OBJECT_START());\n                break;\n\n            case TokenType::BRACKET_OPEN():\n                $this->push(array(), ParserState::ARRAY_START());\n                break;\n\n            case TokenType::STRING_LITERAL():\n            case TokenType::BOOLEAN_LITERAL():\n            case TokenType::NULL_LITERAL():\n            case TokenType::NUMBER_LITERAL():\n                $this->emitValue($token->value());\n                break;\n\n            case TokenType::BRACE_CLOSE():\n            case TokenType::BRACKET_CLOSE():\n            case TokenType::COLON():\n            case TokenType::COMMA():\n                throw $this->createUnexpectedTokenException($token);\n        }\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function doObjectStart(Token $token)\n    {\n        if (TokenType::BRACE_CLOSE() === $token->type()) {\n            $this->emitValue($this->pop());\n        } else {\n            $this->setState(ParserState::OBJECT_KEY());\n            $this->doObjectKey($token);\n        }\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function doObjectKey(Token $token)\n    {\n        if (TokenType::STRING_LITERAL() !== $token->type()) {\n            throw $this->createUnexpectedTokenException($token);\n        }\n\n        $this->setObjectKey($token->value());\n        $this->setState(ParserState::OBJECT_KEY_SEPARATOR());\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function doObjectKeySeparator(Token $token)\n    {\n        if (TokenType::COLON() !== $token->type()) {\n            throw $this->createUnexpectedTokenException($token);\n        }\n\n        $this->setState(ParserState::BEGIN());\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function doObjectValueSeparator(Token $token)\n    {\n        if (TokenType::BRACE_CLOSE() === $token->type()) {\n            $this->emitValue($this->pop());\n        } elseif (TokenType::COMMA() === $token->type()) {\n            $this->setState(ParserState::OBJECT_KEY());\n        } else {\n            throw $this->createUnexpectedTokenException($token);\n        }\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function doArrayStart(Token $token)\n    {\n        if (TokenType::BRACKET_CLOSE() === $token->type()) {\n            $this->emitValue($this->pop());\n        } else {\n            $this->setState(ParserState::BEGIN());\n            $this->doValue($token);\n        }\n    }\n\n    \/**\n     * @param Token $token\n     *\/\n    private function doArrayValueSeparator(Token $token)\n    {\n        if (TokenType::BRACKET_CLOSE() === $token->type()) {\n            $this->emitValue($this->pop());\n        } elseif (TokenType::COMMA() === $token->type()) {\n            $this->setState(ParserState::BEGIN());\n        } else {\n            throw $this->createUnexpectedTokenException($token);\n        }\n    }\n\n    \/**\n     * @param mixed $value\n     *\/\n    private function emitValue($value)\n    {\n        if ($this->stack->isEmpty()) {\n            $this->emit('document', array($value));\n        } else {\n            $entry = $this->stack->next();\n\n            if (is_object($entry->value)) {\n                $entry->value->{$entry->key} = $value;\n                $entry->state = ParserState::OBJECT_VALUE_SEPARATOR();\n                $entry->key = null;\n            } elseif (is_array($entry->value)) {\n                $entry->value[] = $value;\n                $entry->state = ParserState::ARRAY_VALUE_SEPARATOR();\n            }\n        }\n\n        if (!is_object($value) && !is_array($value)) {\n            $this->emit('value', array($value));\n        }\n    }\n\n    \/**\n     * @param ParserState $state\n     *\/\n    private function setState(ParserState $state)\n    {\n        $this->stack->next()->state = $state;\n    }\n\n    \/**\n     * @param string $key\n     *\/\n    private function setObjectKey($key)\n    {\n        $this->stack->next()->key = $key;\n\n        $this->emit('object.key', array($key));\n    }\n\n    \/**\n     * @param mixed       $value\n     * @param ParserState $state\n     *\/\n    private function push($value, ParserState $state)\n    {\n        $entry = new stdClass;\n        $entry->value = $value;\n        $entry->key = null;\n        $entry->state = $state;\n        $this->stack->push($entry);\n\n        if (is_array($value)) {\n            $this->emit('array-open');\n        } elseif (is_object($value)) {\n            $this->emit('object-open');\n        }\n    }\n\n    \/**\n     * @return stdClass\n     *\/\n    private function pop()\n    {\n        $value = $this->stack->pop()->value;\n\n        if (is_array($value)) {\n            $this->emit('array-close');\n        } elseif (is_object($value)) {\n            $this->emit('object-close');\n        }\n\n        return $value;\n    }\n\n    \/**\n     * @param Token $token\n     *\n     * @return Exception\\ParserException\n     *\/\n    private function createUnexpectedTokenException(Token $token)\n    {\n        if ($this->stack->isEmpty()) {\n            return new Exception\\ParserException('Unexpected token \"' . $token->type() . '\".');\n        }\n\n        return new Exception\\ParserException('Unexpected token \"' . $token->type() . '\" in state \"' . $this->stack->next()->state . '\".');\n    }\n\n    private $typeCheck;\n    private $stack;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,38,null,38,38,null,null,null,null,null,null,38,null,38,38,null,null,null,null,null,null,null,null,38,null,38,38,34,30,null,null,null,null,null,null,null,null,30,null,30,2,null,28,null,null,null,null,null,null,38,20,20,10,18,8,15,13,10,2,10,8,9,7,9,9,null,38,null,null,null,null,null,null,null,38,38,14,14,null,31,11,11,null,25,25,25,25,21,21,null,4,4,4,4,4,34,34,null,null,null,null,null,null,13,6,6,9,9,null,12,null,null,null,null,null,null,9,1,null,null,8,8,8,null,null,null,null,null,null,8,1,null,null,7,7,null,null,null,null,null,null,7,6,7,2,2,1,null,6,null,null,null,null,null,null,10,3,3,8,8,null,10,null,null,null,null,null,null,8,7,8,3,3,1,null,7,null,null,null,null,null,null,30,28,28,14,null,14,7,7,7,14,8,8,8,null,null,30,21,21,30,null,null,null,null,null,null,16,16,null,null,null,null,null,null,8,null,8,8,null,null,null,null,null,null,null,22,22,22,22,22,null,22,11,22,14,14,22,null,null,null,null,null,null,16,null,16,9,16,10,10,null,16,null,null,null,null,null,null,null,null,null,8,4,null,null,4,null,null,null,null,null]},{"name":"Icecave\/Duct\/Detail\/TokenType.php","source":"<?php\nnamespace Icecave\\Duct\\Detail;\n\nuse Eloquent\\Enumeration\\Enumeration;\n\nclass TokenType extends Enumeration\n{\n    const BRACE_OPEN      = '{';\n    const BRACE_CLOSE     = '}';\n    const BRACKET_OPEN    = '[';\n    const BRACKET_CLOSE   = ']';\n    const COLON           = ':';\n    const COMMA           = ',';\n    const STRING_LITERAL  = 'string_literal';\n    const BOOLEAN_LITERAL = 'boolean_literal';\n    const NULL_LITERAL    = 'null_literal';\n    const NUMBER_LITERAL  = 'number_literal';\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"Icecave\/Duct\/EventedParser.php","source":"<?php\nnamespace Icecave\\Duct;\n\nuse Evenement\\EventEmitterInterface;\nuse Icecave\\Duct\\Detail\\Lexer;\nuse Icecave\\Duct\\Detail\\TokenStreamParser;\nuse Icecave\\Duct\\TypeCheck\\TypeCheck;\n\n\/**\n * Streaming JSON parser.\n *\n * Converts incoming streams of JSON data into PHP values.\n *\/\nclass EventedParser extends AbstractParser implements EventEmitterInterface\n{\n    \/**\n     * @param Lexer|null             $lexer  The lexer to use for tokenization, or NULL to use the default UTF-8 lexer.\n     * @param TokenStreamParser|null $parser The token-stream parser to use for converting tokens into PHP values, or null to use the default.\n     *\/\n    public function __construct(Lexer $lexer = null, TokenStreamParser $parser = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct($lexer, $parser);\n    }\n\n    \/**\n     * @param string   $event\n     * @param callable $listener\n     *\/\n    public function on($event, $listener)\n    {\n        $this->typeCheck->on(func_get_args());\n\n        return $this->parser->on($event, $listener);\n    }\n\n    \/**\n     * @param string   $event\n     * @param callable $listener\n     *\/\n    public function once($event, $listener)\n    {\n        $this->typeCheck->once(func_get_args());\n\n        return $this->parser->once($event, $listener);\n    }\n\n    \/**\n     * @param string   $event\n     * @param callable $listener\n     *\/\n    public function removeListener($event, $listener)\n    {\n        $this->typeCheck->removeListener(func_get_args());\n\n        return $this->parser->removeListener($event, $listener);\n    }\n\n    \/**\n     * @param string|null $event\n     *\/\n    public function removeAllListeners($event = null)\n    {\n        $this->typeCheck->removeAllListeners(func_get_args());\n\n        return $this->parser->removeAllListeners($event);\n    }\n\n    \/**\n     * @param string $event\n     *\n     * @return array<callable>\n     *\/\n    public function listeners($event)\n    {\n        $this->typeCheck->listeners(func_get_args());\n\n        return $this->parser->listeners($event);\n    }\n\n    \/**\n     * @param string $event\n     * @param array  $arguments\n     *\/\n    public function emit($event, array $arguments = array())\n    {\n        $this->typeCheck->emit(func_get_args());\n\n        $this->parser->emit($event, $arguments);\n    }\n\n    private $typeCheck;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,7,null,7,7,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,1,null,1,1,null,null,null]},{"name":"Icecave\/Duct\/Exception\/SyntaxExceptionInterface.php","source":"<?php\nnamespace Icecave\\Duct\\Exception;\n\ninterface SyntaxExceptionInterface\n{\n}","coverage":[null,null,null,null,null,null]},{"name":"Icecave\/Duct\/Parser.php","source":"<?php\nnamespace Icecave\\Duct;\n\nuse Icecave\\Collections\\Vector;\nuse Icecave\\Duct\\Detail\\Lexer;\nuse Icecave\\Duct\\Detail\\TokenStreamParser;\nuse Icecave\\Duct\\TypeCheck\\TypeCheck;\n\n\/**\n * Streaming JSON parser.\n *\n * Converts incoming streams of JSON data into PHP values.\n *\/\nclass Parser extends AbstractParser\n{\n    \/**\n     * @param Lexer|null             $lexer  The lexer to use for tokenization, or NULL to use the default UTF-8 lexer.\n     * @param TokenStreamParser|null $parser The token-stream parser to use for converting tokens into PHP values, or null to use the default.\n     *\/\n    public function __construct(Lexer $lexer = null, TokenStreamParser $parser = null)\n    {\n        $this->typeCheck = TypeCheck::get(__CLASS__, func_get_args());\n\n        parent::__construct($lexer, $parser);\n\n        $this->values = $values = new Vector;\n\n        $this->parser->on(\n            'document',\n            array($this->values, 'pushBack')\n        );\n    }\n\n    \/**\n     * Parse one or more complete JSON values.\n     *\n     * @param string $buffer The JSON data.\n     *\n     * @return Vector<mixed>             The sequence of parsed JSON values.\n     * @throws Exception\\ParserException Indicates that the JSON stream terminated midway through a JSON value.\n     *\/\n    public function parse($buffer)\n    {\n        $this->typeCheck->parse(func_get_args());\n\n        parent::parse($buffer);\n\n        return $this->values();\n    }\n\n    \/**\n     * Fetch the values produced by the parser so far and remove them from the internal value sequence.\n     *\n     * @return Vector<mixed> The sequence of parsed JSON values.\n     *\/\n    public function values()\n    {\n        $this->typeCheck->values(func_get_args());\n\n        $values = clone $this->values;\n\n        $this->values->clear();\n\n        return $values;\n    }\n\n    private $typeCheck;\n    private $values;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,7,null,7,null,7,null,7,7,7,7,7,null,null,null,null,null,null,null,null,null,null,null,7,null,7,null,7,null,null,null,null,null,null,null,null,null,7,null,7,null,7,null,7,null,null,null,null,null]}]}